package ca.pfv.spmf.algorithms.frequentpatterns.fpgrowth;

/* This file is copyright (c) 2008-2015 Philippe Fournier-Viger
* 
* This file is part of the SPMF DATA MINING SOFTWARE
* (http://www.philippe-fournier-viger.com/spmf).
* 
* SPMF is free software: you can redistribute it and/or modify it under the
* terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
* 
* SPMF is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
* You should have received a copy of the GNU General Public License along with
* SPMF. If not, see <http://www.gnu.org/licenses/>.
*/


import ca.pfv.spmf.patterns.itemset_array_integers_with_count.Itemset;

import java.util.Comparator;


/**
 * This is an implementation of a CFITree as used by the FPClose algorithm.
 *
 * @see CFINode
 * @see Itemset
 * @see AlgoFPClose
 * @author Philippe Fournier-Viger
 */
public class CFITree extends FITree {
	
	// The order on items stored in the tree
	Comparator<Integer> comparatorOriginalOrder = null;
	
	
	//========================= METHODS NOT USED  BY FPCLOSE =============================/
	
	/**
	 * This method calculate the support of any frequent itemset by using the CFI-tree containing all the
	 * frequent closed itemsets. 
	 * Note that this method assumes that all frequent closed itemsets are stored in the CFI-tree.
	 * 
	 * **** It is not used by FPClose***. 
	 * 
	 * It is instead designed for algorithms
	 * that use the CFI-tree generated by FPClose such as the algorithm for generating closed
	 * association rules.
	 * @param itemset the itemset that we want to calculate the support
	 * @return the support of that itemset as a number of transaction
	 */
	public int calculateSupport(int[] itemset) {
		sortOriginalOrder(itemset, itemset.length);
		
		// Find the node list for the first item of the itemset
		Integer firstITem = itemset[itemset.length-1];
		
		// OTHERWISE, WE NEED TO COMPARE "headwithP" with all the patterns in the CFI-tree.
		FINode node = mapItemNodes.get(firstITem);

		int maxSupport = -1;
		// we will loop over each node by following node links
		do {
			// for a node, we will check if "headwithP" is a subset of the path ending at node
			if(issASubsetOfPrefixPath(itemset, itemset.length, node)){
				if(node.counter > maxSupport){
					maxSupport = node.counter;
//					return node.counter;
				}
			}
			// go to the next itemset to test
			node = node.nodeLink;
		}while(node != null);
		
		if(maxSupport != -1){
			return maxSupport;
		}

		throw new Error("CFI-Tree: itemset not found. This should not happen");
	}



	/**
	 * Set the comparator (the total order on items)
	 * @param comparatorOriginalOrder a comparator
	 */
	public void setComparator(Comparator<Integer> comparatorOriginalOrder) {
		this.comparatorOriginalOrder = comparatorOriginalOrder;
		
	}
	
	/**
	 * Sort an array of items according to the total order of support
	 * This has an average performance of O(n^2)
	 * @param a array of integers
	 */
	public void sortOriginalOrder(int [] a, int length){
		// Perform a bubble sort
		for(int i=0; i < length; i++){
			for(int j= length -1; j>= i+1; j--){
				boolean test = comparatorOriginalOrder.compare(a[j], a[j-1]) < 0;
				if(test){
					int temp = a[j];
					a[j] = a[j-1];
					a[j-1] = temp;
				}
			}
		}

	}

}
